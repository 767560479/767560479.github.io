import{_ as a,o as t,c as l,a as r}from"./app.f86949ad.js";const p=JSON.parse('{"title":"八股文","description":"","frontmatter":{},"headers":[{"level":3,"title":"述说React和Vue的区别","slug":"述说react和vue的区别","link":"#述说react和vue的区别","children":[]},{"level":3,"title":"redux主要解决什么问题？有什么优缺点？","slug":"redux主要解决什么问题-有什么优缺点","link":"#redux主要解决什么问题-有什么优缺点","children":[]},{"level":3,"title":"如何划分业务组件和技术组件？","slug":"如何划分业务组件和技术组件","link":"#如何划分业务组件和技术组件","children":[]},{"level":3,"title":"React生命周期函数","slug":"react生命周期函数","link":"#react生命周期函数","children":[]},{"level":3,"title":"React性能优化方案有哪些？和哪个周期函数关联性较大？","slug":"react性能优化方案有哪些-和哪个周期函数关联性较大","link":"#react性能优化方案有哪些-和哪个周期函数关联性较大","children":[]},{"level":3,"title":"为什么虚拟dom会提高性能？","slug":"为什么虚拟dom会提高性能","link":"#为什么虚拟dom会提高性能","children":[]},{"level":3,"title":"DOMDiff算法？","slug":"domdiff算法","link":"#domdiff算法","children":[]},{"level":3,"title":"简述flux思想React项目用过什么脚手架？","slug":"简述flux思想react项目用过什么脚手架","link":"#简述flux思想react项目用过什么脚手架","children":[]},{"level":3,"title":"React解决了什么问题？","slug":"react解决了什么问题","link":"#react解决了什么问题","children":[]},{"level":3,"title":"React的工作原理？","slug":"react的工作原理","link":"#react的工作原理","children":[]},{"level":3,"title":"使用React有何优点？","slug":"使用react有何优点","link":"#使用react有何优点","children":[]},{"level":3,"title":"展示组件（Presentationalcomponent）和容器组件(Containercomponent)之间有何不同？","slug":"展示组件-presentationalcomponent-和容器组件-containercomponent-之间有何不同","link":"#展示组件-presentationalcomponent-和容器组件-containercomponent-之间有何不同","children":[]},{"level":3,"title":"类组件(Classcomponent)和函数式组件（Functionalcomponent）之间有何不同？","slug":"类组件-classcomponent-和函数式组件-functionalcomponent-之间有何不同","link":"#类组件-classcomponent-和函数式组件-functionalcomponent-之间有何不同","children":[]},{"level":3,"title":"状态(state)和属性（props）之间有何不同？","slug":"状态-state-和属性-props-之间有何不同","link":"#状态-state-和属性-props-之间有何不同","children":[]},{"level":3,"title":"应该在React组件的何处发起Ajax请求？","slug":"应该在react组件的何处发起ajax请求","link":"#应该在react组件的何处发起ajax请求","children":[]},{"level":3,"title":"在React 中，refs 的作用是什么？","slug":"在react-中-refs-的作用是什么","link":"#在react-中-refs-的作用是什么","children":[]},{"level":3,"title":"何为高阶组件(higherordercomponent)？","slug":"何为高阶组件-higherordercomponent","link":"#何为高阶组件-higherordercomponent","children":[]},{"level":3,"title":"为什么建议传递给setState的参数是一个callback而不是一个对象？","slug":"为什么建议传递给setstate的参数是一个callback而不是一个对象","link":"#为什么建议传递给setstate的参数是一个callback而不是一个对象","children":[]},{"level":3,"title":"除了在构造函数中绑定this，还有其它方式吗？","slug":"除了在构造函数中绑定this-还有其它方式吗","link":"#除了在构造函数中绑定this-还有其它方式吗","children":[]},{"level":3,"title":"怎么阻止组件的渲染？","slug":"怎么阻止组件的渲染","link":"#怎么阻止组件的渲染","children":[]},{"level":3,"title":"当渲染一个列表时，何为key？设置key的目的是什么？","slug":"当渲染一个列表时-何为key-设置key的目的是什么","link":"#当渲染一个列表时-何为key-设置key的目的是什么","children":[]},{"level":3,"title":"为什么要设计React hook，它解决了什么问题？","slug":"为什么要设计react-hook-它解决了什么问题","link":"#为什么要设计react-hook-它解决了什么问题","children":[]}],"relativePath":"08.React/八股文.md","lastUpdated":1764085184000}'),i={name:"08.React/八股文.md"};function n(c,e,h,d,o,s){return t(),l("div",{"data-pagefind-body":!0},[...e[0]||(e[0]=[r('<h1 id="八股文" tabindex="-1">八股文 <a class="header-anchor" href="#八股文" aria-hidden="true">#</a></h1><h3 id="述说react和vue的区别" tabindex="-1">述说React和Vue的区别 <a class="header-anchor" href="#述说react和vue的区别" aria-hidden="true">#</a></h3><h3 id="redux主要解决什么问题-有什么优缺点" tabindex="-1">redux主要解决什么问题？有什么优缺点？ <a class="header-anchor" href="#redux主要解决什么问题-有什么优缺点" aria-hidden="true">#</a></h3><h3 id="如何划分业务组件和技术组件" tabindex="-1">如何划分业务组件和技术组件？ <a class="header-anchor" href="#如何划分业务组件和技术组件" aria-hidden="true">#</a></h3><h3 id="react生命周期函数" tabindex="-1">React生命周期函数 <a class="header-anchor" href="#react生命周期函数" aria-hidden="true">#</a></h3><h3 id="react性能优化方案有哪些-和哪个周期函数关联性较大" tabindex="-1">React性能优化方案有哪些？和哪个周期函数关联性较大？ <a class="header-anchor" href="#react性能优化方案有哪些-和哪个周期函数关联性较大" aria-hidden="true">#</a></h3><h3 id="为什么虚拟dom会提高性能" tabindex="-1">为什么虚拟dom会提高性能？ <a class="header-anchor" href="#为什么虚拟dom会提高性能" aria-hidden="true">#</a></h3><h3 id="domdiff算法" tabindex="-1">DOMDiff算法？ <a class="header-anchor" href="#domdiff算法" aria-hidden="true">#</a></h3><h3 id="简述flux思想react项目用过什么脚手架" tabindex="-1">简述flux思想React项目用过什么脚手架？ <a class="header-anchor" href="#简述flux思想react项目用过什么脚手架" aria-hidden="true">#</a></h3><h3 id="react解决了什么问题" tabindex="-1">React解决了什么问题？ <a class="header-anchor" href="#react解决了什么问题" aria-hidden="true">#</a></h3><h3 id="react的工作原理" tabindex="-1">React的工作原理？ <a class="header-anchor" href="#react的工作原理" aria-hidden="true">#</a></h3><h3 id="使用react有何优点" tabindex="-1">使用React有何优点？ <a class="header-anchor" href="#使用react有何优点" aria-hidden="true">#</a></h3><h3 id="展示组件-presentationalcomponent-和容器组件-containercomponent-之间有何不同" tabindex="-1">展示组件（Presentationalcomponent）和容器组件(Containercomponent)之间有何不同？ <a class="header-anchor" href="#展示组件-presentationalcomponent-和容器组件-containercomponent-之间有何不同" aria-hidden="true">#</a></h3><h3 id="类组件-classcomponent-和函数式组件-functionalcomponent-之间有何不同" tabindex="-1">类组件(Classcomponent)和函数式组件（Functionalcomponent）之间有何不同？ <a class="header-anchor" href="#类组件-classcomponent-和函数式组件-functionalcomponent-之间有何不同" aria-hidden="true">#</a></h3><h3 id="状态-state-和属性-props-之间有何不同" tabindex="-1">状态(state)和属性（props）之间有何不同？ <a class="header-anchor" href="#状态-state-和属性-props-之间有何不同" aria-hidden="true">#</a></h3><h3 id="应该在react组件的何处发起ajax请求" tabindex="-1">应该在React组件的何处发起Ajax请求？ <a class="header-anchor" href="#应该在react组件的何处发起ajax请求" aria-hidden="true">#</a></h3><h3 id="在react-中-refs-的作用是什么" tabindex="-1">在React 中，refs 的作用是什么？ <a class="header-anchor" href="#在react-中-refs-的作用是什么" aria-hidden="true">#</a></h3><p>答案： Refs提供了一种访问DOM元素或React元素的方法，这在某些情况下非常有用，例如聚焦输入、测量文本或触发动画。Refs是使用React.createRef()创建的，并通过ref属性附加到React元素上。使用Refs可以访问DOM节点或在组件中存储组件实例。</p><h3 id="何为高阶组件-higherordercomponent" tabindex="-1">何为高阶组件(higherordercomponent)？ <a class="header-anchor" href="#何为高阶组件-higherordercomponent" aria-hidden="true">#</a></h3><p>答案：高阶组件是参数为组件，返回值为新组件的函数。HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC是React中高级技巧，用来重用组件逻辑。</p><h3 id="为什么建议传递给setstate的参数是一个callback而不是一个对象" tabindex="-1">为什么建议传递给setState的参数是一个callback而不是一个对象？ <a class="header-anchor" href="#为什么建议传递给setstate的参数是一个callback而不是一个对象" aria-hidden="true">#</a></h3><ul><li><p>异步更新：React会将多个setState()调用合并为单个更新，以提高性能。当直接传递个对象时，React可能会对多个setState()调用进行批量处理导致只有最后一个调用生效。而通过传递一个回调函数，可以确保每个setState()都会以当前的状态为基础进行更新。</p></li><li><p>避免竞态条件（RaceConditions）：由于setState()是异步的，多个setState调用可能会导致竟态条件。如果多个setState（）调用依赖于先前的状态，并且都是直接传递对象，可能导致不准确的结果。而通过传递一个回调函数，可以确保每个setState()都是基于最新的状态进行操作，避免了竞态条件。</p></li><li><p>优化性能：通过传递回调函数，可以使用前一个状态作为参数，并返回一个新的状态对象。这样可以避免每次更新都创建一个新的状态对象，从而优化性能和内存使用。</p></li></ul><h3 id="除了在构造函数中绑定this-还有其它方式吗" tabindex="-1">除了在构造函数中绑定this，还有其它方式吗？ <a class="header-anchor" href="#除了在构造函数中绑定this-还有其它方式吗" aria-hidden="true">#</a></h3><p>答案：使用属性初始化器语法，class 中的方法默认不会绑定this。如果忘记绑定this.handleClick 并把它传入了onClick，那么它将是一个 undefined。</p><h3 id="怎么阻止组件的渲染" tabindex="-1">怎么阻止组件的渲染？ <a class="header-anchor" href="#怎么阻止组件的渲染" aria-hidden="true">#</a></h3><p>答案：</p><ul><li>利用内联条件渲染来控制组件的渲染，不渲染组件。</li><li>利用React.Component 实现componentWillMount() 方法，在方法中返回 null 或者 false。</li><li>利用React.PureComponent 实现 shouldComponentUpdate() 方法，并返回 false。</li></ul><h3 id="当渲染一个列表时-何为key-设置key的目的是什么" tabindex="-1">当渲染一个列表时，何为key？设置key的目的是什么？ <a class="header-anchor" href="#当渲染一个列表时-何为key-设置key的目的是什么" aria-hidden="true">#</a></h3><p>答案：</p><ul><li>key是React用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</li><li>简单的说，key应该是唯一的。</li><li>推荐在循环中使用key，key会传递信息给React，但不会显示出来。</li><li>key应该使用字符串或者数字，也可以使用React元素作为key。</li><li>通常，使用数据中的唯一标识符作为key。</li></ul><h3 id="为什么要设计react-hook-它解决了什么问题" tabindex="-1">为什么要设计React hook，它解决了什么问题？ <a class="header-anchor" href="#为什么要设计react-hook-它解决了什么问题" aria-hidden="true">#</a></h3><p>答案：</p><ul><li>组件之间逻辑复用难。</li><li>复杂组件变得难以理解。</li><li>难以理解的class。</li><li>难以记忆的生命周期。</li></ul>',33)])])}const f=a(i,[["render",n]]);export{p as __pageData,f as default};
