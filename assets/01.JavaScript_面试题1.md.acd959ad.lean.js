import{_ as n,o as a,c as l,a as e}from"./app.e51826c1.js";const D=JSON.parse('{"title":"面试题","description":"","frontmatter":{"sidebar":{"title":"面试题"},"isTimeLine":true,"title":"面试题","date":"2024-01-12T00:00:00.000Z","tags":["前端","面试"],"categories":["前端"]},"headers":[{"level":2,"title":"介绍下观察者模式","slug":"介绍下观察者模式","link":"#介绍下观察者模式","children":[]},{"level":2,"title":"介绍下发布订阅模式","slug":"介绍下发布订阅模式","link":"#介绍下发布订阅模式","children":[]},{"level":2,"title":"观察者模式和发布订阅模式","slug":"观察者模式和发布订阅模式","link":"#观察者模式和发布订阅模式","children":[]},{"level":2,"title":"介绍下 DFS 深度优先搜索算法","slug":"介绍下-dfs-深度优先搜索算法","link":"#介绍下-dfs-深度优先搜索算法","children":[]},{"level":2,"title":"介绍下 BFS 广度优先搜索算法","slug":"介绍下-bfs-广度优先搜索算法","link":"#介绍下-bfs-广度优先搜索算法","children":[]},{"level":2,"title":"介绍下 KMP 算法","slug":"介绍下-kmp-算法","link":"#介绍下-kmp-算法","children":[]},{"level":2,"title":"React 生命周期","slug":"react-生命周期","link":"#react-生命周期","children":[]},{"level":2,"title":"React 中的 setState 是同步还是异步的？","slug":"react-中的-setstate-是同步还是异步的","link":"#react-中的-setstate-是同步还是异步的","children":[]},{"level":2,"title":"介绍下 React 中的合成事件","slug":"介绍下-react-中的合成事件","link":"#介绍下-react-中的合成事件","children":[]},{"level":2,"title":"React 性能优化","slug":"react-性能优化","link":"#react-性能优化","children":[]},{"level":2,"title":"介绍下 React 中的 Fiber 算法","slug":"介绍下-react-中的-fiber-算法","link":"#介绍下-react-中的-fiber-算法","children":[]},{"level":2,"title":"添加原生事件不移除为什么会内存泄露","slug":"添加原生事件不移除为什么会内存泄露","link":"#添加原生事件不移除为什么会内存泄露","children":[]},{"level":2,"title":"还有哪些地方会内存泄露","slug":"还有哪些地方会内存泄露","link":"#还有哪些地方会内存泄露","children":[]},{"level":2,"title":"setlnterval 需要注意的点","slug":"setlnterval-需要注意的点","link":"#setlnterval-需要注意的点","children":[]},{"level":2,"title":"定时器为什么是不精确的","slug":"定时器为什么是不精确的","link":"#定时器为什么是不精确的","children":[]},{"level":2,"title":"介绍下 React 的 diff 算法","slug":"介绍下-react-的-diff-算法","link":"#介绍下-react-的-diff-算法","children":[]},{"level":2,"title":"React 的 diff 算法和 Vue 的 diff 算法的区别","slug":"react-的-diff-算法和-vue-的-diff-算法的区别","link":"#react-的-diff-算法和-vue-的-diff-算法的区别","children":[]},{"level":2,"title":"介绍宏任务和微任务","slug":"介绍宏任务和微任务","link":"#介绍宏任务和微任务","children":[]},{"level":2,"title":"Promise 里面执行和 then 里面执行有什么区别","slug":"promise-里面执行和-then-里面执行有什么区别","link":"#promise-里面执行和-then-里面执行有什么区别","children":[]},{"level":2,"title":"介绍 pureComponet","slug":"介绍-purecomponet","link":"#介绍-purecomponet","children":[]},{"level":2,"title":"介绍 FunctionComponent","slug":"介绍-functioncomponent","link":"#介绍-functioncomponent","children":[]},{"level":2,"title":"React 数据流","slug":"react-数据流","link":"#react-数据流","children":[]},{"level":2,"title":"props 和 state 的区别","slug":"props-和-state-的区别","link":"#props-和-state-的区别","children":[]},{"level":2,"title":"介绍 Reactcontext","slug":"介绍-reactcontext","link":"#介绍-reactcontext","children":[]},{"level":2,"title":"介绍 class 和 ES5 的类以及区别","slug":"介绍-class-和-es5-的类以及区别","link":"#介绍-class-和-es5-的类以及区别","children":[]},{"level":2,"title":"介绍箭头函数和普通函数的区别","slug":"介绍箭头函数和普通函数的区别","link":"#介绍箭头函数和普通函数的区别","children":[]},{"level":2,"title":"for..in 和 object.keys 的区别","slug":"for-in-和-object-keys-的区别","link":"#for-in-和-object-keys-的区别","children":[]},{"level":2,"title":"介绍下 Vue 的 nextTick","slug":"介绍下-vue-的-nexttick","link":"#介绍下-vue-的-nexttick","children":[]},{"level":2,"title":"如何检测对象是否循环引用？","slug":"如何检测对象是否循环引用","link":"#如何检测对象是否循环引用","children":[{"level":3,"title":"一、递归遍历 + 哈希表（Set/WeakSet） [推荐方法]","slug":"一、递归遍历-哈希表-set-weakset-推荐方法","link":"#一、递归遍历-哈希表-set-weakset-推荐方法","children":[]},{"level":3,"title":"二、JSON.stringify 异常捕获法","slug":"二、json-stringify-异常捕获法","link":"#二、json-stringify-异常捕获法","children":[]},{"level":3,"title":"三、方法对比与选择建议","slug":"三、方法对比与选择建议","link":"#三、方法对比与选择建议","children":[]},{"level":3,"title":"四、扩展：循环引用的实际影响","slug":"四、扩展-循环引用的实际影响","link":"#四、扩展-循环引用的实际影响","children":[]}]},{"level":2,"title":"postMessage 是如何解决跨域问题的？","slug":"postmessage-是如何解决跨域问题的","link":"#postmessage-是如何解决跨域问题的","children":[]},{"level":2,"title":"js 对象可以使用 for...of 迭代吗？","slug":"js-对象可以使用-for-of-迭代吗","link":"#js-对象可以使用-for-of-迭代吗","children":[]}],"relativePath":"01.JavaScript/面试题1.md","lastUpdated":1763557946000}'),o={name:"01.JavaScript/面试题1.md"};function p(t,s,r,c,i,y){return a(),l("div",{"data-pagefind-body":!0},[...s[0]||(s[0]=[e(`<h1 id="面试题-1" tabindex="-1">面试题 1 <a class="header-anchor" href="#面试题-1" aria-hidden="true">#</a></h1><h2 id="介绍下观察者模式" tabindex="-1">介绍下观察者模式 <a class="header-anchor" href="#介绍下观察者模式" aria-hidden="true">#</a></h2><ul><li>观察者模式是一种设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式包含两个角色：主题（Subject）和观察者（Observer）。主题对象负责发布通知，同时观察者对象订阅主题，以便在主题发生改变时收到通知。</li><li>观察者模式的使用场景包括：事件处理、状态监听、数据绑定等。</li></ul><h2 id="介绍下发布订阅模式" tabindex="-1">介绍下发布订阅模式 <a class="header-anchor" href="#介绍下发布订阅模式" aria-hidden="true">#</a></h2><ul><li>发布订阅模式是一种设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>发布订阅模式包含两个角色：发布者（Publisher）和订阅者（Subscriber）。发布者负责发布通知，同时订阅者对象订阅主题，以便在主题发生改变时收到通知。</li><li>发布订阅模式的使用场景包括：事件处理、状态监听、数据绑定等。</li></ul><h2 id="观察者模式和发布订阅模式" tabindex="-1">观察者模式和发布订阅模式 <a class="header-anchor" href="#观察者模式和发布订阅模式" aria-hidden="true">#</a></h2><ul><li>观察者模式是一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>发布订阅模式是一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式和发布订阅模式都是用于处理一对多的依赖关系，但是它们在实现方式上有所不同。观察者模式是通过主题对象的 notify 方法来通知观察者对象的，而发布订阅模式是通过消息队列来实现的。</li></ul><h2 id="介绍下-dfs-深度优先搜索算法" tabindex="-1">介绍下 DFS 深度优先搜索算法 <a class="header-anchor" href="#介绍下-dfs-深度优先搜索算法" aria-hidden="true">#</a></h2><ul><li>DFS（Depth-First Search）是一种用于遍历或搜索树或图的算法。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯（回溯的定义是沿原路返回）。</li><li>DFS 的实现需要使用栈数据结构来保存已经访问过的节点，以便在需要时回溯。</li><li>DFS 的复杂度取决于树的形态和节点之间的连接方式。在最坏情况下，DFS 需要遍历整棵树，时间复杂度为 O(n)。在平均情况下，DFS 的时间复杂度为 O(log n)。</li></ul><p>例如：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">dfs</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">node</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">node</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">visited</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#BABED8;">node</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">visited</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">node</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">value</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">node</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">length</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">dfs</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">node</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">i</span><span style="color:#F07178;">])</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="介绍下-bfs-广度优先搜索算法" tabindex="-1">介绍下 BFS 广度优先搜索算法 <a class="header-anchor" href="#介绍下-bfs-广度优先搜索算法" aria-hidden="true">#</a></h2><ul><li>BFS（Breadth-First Search）是一种用于遍历或搜索树或图的算法。它从树的根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。</li><li>BFS 的实现需要使用队列数据结构来保存已经访问过的节点，以便在需要时进行访问。</li><li>BFS 的复杂度取决于树的形态和节点之间的连接方式。在最坏情况下，BFS 需要遍历整棵树，时间复杂度为 O(n)。在平均情况下，BFS 的时间复杂度为 O(log n)。</li></ul><p>例如：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">bfs</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">node</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">queue</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#BABED8;">node</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">currentNode</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">shift</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">currentNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">visited</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">continue</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">currentNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">visited</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">currentNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">value</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">currentNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">length</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#BABED8;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">currentNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">children</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">i</span><span style="color:#F07178;">])</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="介绍下-kmp-算法" tabindex="-1">介绍下 KMP 算法 <a class="header-anchor" href="#介绍下-kmp-算法" aria-hidden="true">#</a></h2><ul><li>KMP（Knuth-Morris-Pratt）是一种字符串匹配算法，它通过使用模式串的信息来提高匹配的效率。</li><li>KMP 算法通过构建一个 next 数组来保存模式串的前缀和后缀的最长公共子串的长度，从而避免重复匹配。</li><li>KMP 算法的复杂度取决于模式串的长度。在最坏情况下，KMP 算法需要遍历整棵树，时间复杂度为 O(n)。在平均情况下，KMP 算法的复杂度为 O(m)。</li></ul><h2 id="react-生命周期" tabindex="-1">React 生命周期 <a class="header-anchor" href="#react-生命周期" aria-hidden="true">#</a></h2><ul><li>挂载阶段：组件被创建并插入到 DOM 中</li><li>更新阶段：组件被重新渲染</li><li>卸载阶段：组件被从 DOM 中移除</li></ul><h2 id="react-中的-setstate-是同步还是异步的" tabindex="-1">React 中的 setState 是同步还是异步的？ <a class="header-anchor" href="#react-中的-setstate-是同步还是异步的" aria-hidden="true">#</a></h2><ul><li>在 React 中，setState 是异步的。</li><li>这意味着当调用 setState 时，React 不会立即更新组件的状态，而是将更新添加到更新队列中，然后在适当的时机进行状态更新。</li><li>这样可以提高性能并避免不必要的重复渲染。</li><li>然而，在某些情况下，setState 是同步的，比如在事件处理函数中调用 setState。在这种情况下，setState 会立即更新组件的状态。</li></ul><h2 id="介绍下-react-中的合成事件" tabindex="-1">介绍下 React 中的合成事件 <a class="header-anchor" href="#介绍下-react-中的合成事件" aria-hidden="true">#</a></h2><ul><li>React 中的合成事件是 React 封装的一套事件系统，它屏蔽了浏览器的差异，提供了一致的 API 接口。</li><li>合成事件可以统一处理，比如事件委派、事件池等。</li><li>合成事件可以提高性能，因为减少了与浏览器交互的次数。</li></ul><h2 id="react-性能优化" tabindex="-1">React 性能优化 <a class="header-anchor" href="#react-性能优化" aria-hidden="true">#</a></h2><ul><li>使用 shouldComponentUpdate 钩子函数来优化组件的更新性能。</li><li>使用 PureComponent 代替 Component，PureComponent 会自动进行 props 和 state 的浅比较，只有当 props 或 state 发生变化时才会触发组件的更新。</li><li>使用 immutable.js 来管理状态，这样可以避免直接修改状态，从而减少错误的发生。</li><li>使用 React.memo 和 React.lazy 来优化组件的渲染性能。</li><li>使用 Webpack 的代码分割功能来优化应用的加载性能。</li></ul><h2 id="介绍下-react-中的-fiber-算法" tabindex="-1">介绍下 React 中的 Fiber 算法 <a class="header-anchor" href="#介绍下-react-中的-fiber-算法" aria-hidden="true">#</a></h2><ul><li>Fiber 算法是一种用于 React 16 及更高版本中的虚拟 DOM 渲染算法。</li><li>Fiber 算法将渲染过程分成多个小任务，每个小任务可以在执行过程中被中断，从而实现异步渲染。</li><li>Fiber 算法可以提高渲染性能和用户体验。</li></ul><h2 id="添加原生事件不移除为什么会内存泄露" tabindex="-1">添加原生事件不移除为什么会内存泄露 <a class="header-anchor" href="#添加原生事件不移除为什么会内存泄露" aria-hidden="true">#</a></h2><ul><li>因为移除事件监听器后，事件监听器仍然存在于内存中，无法被垃圾回收器回收。</li><li>因此，添加原生事件不移除会导致内存泄漏。</li><li>解决方案是，在添加事件监听器后，及时移除事件监听器，以避免内存泄漏。</li></ul><h2 id="还有哪些地方会内存泄露" tabindex="-1">还有哪些地方会内存泄露 <a class="header-anchor" href="#还有哪些地方会内存泄露" aria-hidden="true">#</a></h2><ul><li>闭包：闭包会导致闭包函数中的变量无法被垃圾回收器回收。</li><li>定时器：定时器中的变量无法被垃圾回收器回收。</li><li>事件监听器：事件监听器无法被垃圾回收器回收。</li><li>循环引用：两个对象相互引用，导致无法被垃圾回收器回收。</li><li>未释放的 DOM 元素：未释放的 DOM 元素会导致内存泄漏。</li></ul><h2 id="setlnterval-需要注意的点" tabindex="-1">setlnterval 需要注意的点 <a class="header-anchor" href="#setlnterval-需要注意的点" aria-hidden="true">#</a></h2><ul><li>及时清除定时器，避免内存泄漏。</li><li>定时器的时间间隔不要过短，否则会导致 CPU 占用过高。</li><li>定时器的时间间隔不要过长，否则会导致页面卡顿。</li></ul><h2 id="定时器为什么是不精确的" tabindex="-1">定时器为什么是不精确的 <a class="header-anchor" href="#定时器为什么是不精确的" aria-hidden="true">#</a></h2><ul><li>定时器的时间间隔是不精确的，因为定时器的时间间隔是由操作系统决定的，操作系统可能会在定时器的时间间隔内进行其他任务，导致定时器的时间间隔不精确。</li><li>定时器的时间间隔的误差取决于操作系统的调度时间和处理时间，以及硬件设备的性能。</li><li>可以通过使用 setTimeout 来实现更精确的定时器。</li></ul><h2 id="介绍下-react-的-diff-算法" tabindex="-1">介绍下 React 的 diff 算法 <a class="header-anchor" href="#介绍下-react-的-diff-算法" aria-hidden="true">#</a></h2><ul><li>React 的 diff 算法是一种高效的算法，用于比较两个虚拟 DOM 树的差异，从而最小化更新操作。</li><li>React 的 diff 算法会首先比较两个虚拟 DOM 树的根节点，然后递归比较子节点，最后生成一个新的虚拟 DOM 树。</li><li>React 的 diff 算法可以减少 DOM 操作的数量，提高渲染性能。</li></ul><h2 id="react-的-diff-算法和-vue-的-diff-算法的区别" tabindex="-1">React 的 diff 算法和 Vue 的 diff 算法的区别 <a class="header-anchor" href="#react-的-diff-算法和-vue-的-diff-算法的区别" aria-hidden="true">#</a></h2><ul><li>React 的 diff 算法是基于虚拟 DOM 的，而 Vue 的 diff 算法是基于真实 DOM 的。</li><li>React 的 diff 算法是递归的，而 Vue 的 diff 算法是双指针的。</li><li>React 的 diff 算法是同步执行的，而 Vue 的 diff 算法是异步执行的。</li></ul><h2 id="介绍宏任务和微任务" tabindex="-1">介绍宏任务和微任务 <a class="header-anchor" href="#介绍宏任务和微任务" aria-hidden="true">#</a></h2><ul><li>宏任务：setTimeout、setInterval、requestAnimationFrame、I/O 操作等。</li><li>微任务：Promise 的回调函数、MutationObserver 的回调函数等。</li><li>宏任务会在当前脚本的所有同步任务执行完毕后执行，微任务会在当前宏任务的所有微任务执行完毕后执行。</li></ul><h2 id="promise-里面执行和-then-里面执行有什么区别" tabindex="-1">Promise 里面执行和 then 里面执行有什么区别 <a class="header-anchor" href="#promise-里面执行和-then-里面执行有什么区别" aria-hidden="true">#</a></h2><ul><li>Promise 里面执行的代码是在 Promise 的构造函数中执行的，then 里面执行的代码是在 Promise 的 then 方法中执行的。</li></ul><h2 id="介绍-purecomponet" tabindex="-1">介绍 pureComponet <a class="header-anchor" href="#介绍-purecomponet" aria-hidden="true">#</a></h2><ul><li>pureComponent 是一个 React 组件，它实现了 shouldComponentUpdate 方法，用于判断组件是否需要重新渲染。如果组件的 props 和 state 没有发生变化，则不会重新渲染组件。</li><li>pureComponent 可以提高组件的性能，减少不必要的渲染。</li><li>pureComponent 默认情况下是浅比较 props 和 state 的，可以通过 shouldComponentUpdate 方法自定义比较规则。</li></ul><h2 id="介绍-functioncomponent" tabindex="-1">介绍 FunctionComponent <a class="header-anchor" href="#介绍-functioncomponent" aria-hidden="true">#</a></h2><ul><li>FunctionComponent 是一个 React 组件，它使用函数来定义组件的逻辑。</li><li>FunctionComponent 可以提高组件的性能，减少不必要的渲染。</li><li>FunctionComponent 可以使用 hooks 来获取组件的状态和生命周期方法。</li></ul><h2 id="react-数据流" tabindex="-1">React 数据流 <a class="header-anchor" href="#react-数据流" aria-hidden="true">#</a></h2><ul><li>React 数据流是单向的，从父组件传递到子组件。</li><li>React 数据流可以通过 props 和 state 来实现。</li><li>React 数据流可以通过 context 来实现跨组件传递数据。</li></ul><h2 id="props-和-state-的区别" tabindex="-1">props 和 state 的区别 <a class="header-anchor" href="#props-和-state-的区别" aria-hidden="true">#</a></h2><ul><li>props 是父组件传递给子组件的数据，只能通过父组件修改。</li><li>state 是组件自身管理的数据，可以通过组件的 setState 方法修改。</li><li>props 是只读的，state 是可读可写的。</li></ul><h2 id="介绍-reactcontext" tabindex="-1">介绍 Reactcontext <a class="header-anchor" href="#介绍-reactcontext" aria-hidden="true">#</a></h2><ul><li>React 的 context 用于在组件树中传递数据。</li><li>React 的 context 可以用于跨组件传递数据，也可以用于跨组件传递函数。</li><li>React 的 context 可以用于跨组件传递组件的状态。</li></ul><h2 id="介绍-class-和-es5-的类以及区别" tabindex="-1">介绍 class 和 ES5 的类以及区别 <a class="header-anchor" href="#介绍-class-和-es5-的类以及区别" aria-hidden="true">#</a></h2><ul><li>class 是 ES6 引入的新语法，用于定义类。</li><li>class 可以继承自其他类，也可以实现接口。</li><li>class 可以定义构造函数、方法、属性等。</li><li>class 可以方便地使用继承、多态等面向对象的概念。</li><li>class 可以方便地使用装饰器。</li><li>class 可以方便地使用静态方法。</li><li>class 可以方便地使用私有属性。</li><li>class 可以方便地使用私有方法。</li><li>class 可以方便地使用抽象类。</li><li>class 可以方便地使用泛型。</li><li>class 可以方便地使用异步。</li></ul><h2 id="介绍箭头函数和普通函数的区别" tabindex="-1">介绍箭头函数和普通函数的区别 <a class="header-anchor" href="#介绍箭头函数和普通函数的区别" aria-hidden="true">#</a></h2><ul><li>箭头函数没有自己的 this，它的 this 是继承自外层作用域的 this。</li><li>箭头函数没有自己的 arguments，它的 arguments 是继承自外层作用域的 arguments。</li><li>箭头函数不能使用 yield 关键字。</li><li>箭头函数不能使用 new 关键字。</li><li>箭头函数不能使用 super 关键字。</li><li>箭头函数不能使用 new.target 关键字。</li><li>箭头函数不能使用 arguments 关键字。</li><li>箭头函数不能使用 eval 关键字。</li><li>箭头函数不能使用 caller 关键字。</li></ul><h2 id="for-in-和-object-keys-的区别" tabindex="-1">for..in 和 object.keys 的区别 <a class="header-anchor" href="#for-in-和-object-keys-的区别" aria-hidden="true">#</a></h2><ul><li>for..in 可以遍历对象的键名。</li><li>object.keys 可以遍历对象的键值。</li><li>for..in 可以遍历原型链上的键名。</li><li>object.keys 只能遍历自身的键名。</li><li>for..in 可以遍历数组的键名。</li><li>object.keys 只能遍历数组的索引。</li></ul><h2 id="介绍下-vue-的-nexttick" tabindex="-1">介绍下 Vue 的 nextTick <a class="header-anchor" href="#介绍下-vue-的-nexttick" aria-hidden="true">#</a></h2><ul><li>Vue 的 nextTick 方法用于在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用 nextTick，获取更新后的 DOM。</li><li>nextTick 方法会返回一个 Promise 对象，可以使用 async/await 语法来等待 DOM 更新完成。</li><li>nextTick 方法可以用于在 DOM 更新之后执行一些操作，例如获取更新后的 DOM 元素。</li></ul><h2 id="如何检测对象是否循环引用" tabindex="-1">如何检测对象是否循环引用？ <a class="header-anchor" href="#如何检测对象是否循环引用" aria-hidden="true">#</a></h2><p>检测对象是否存在循环引用是编程中常见的需求，尤其是在处理复杂数据结构时。以下是几种主流方法及其实现原理：</p><hr><h3 id="一、递归遍历-哈希表-set-weakset-推荐方法" tabindex="-1">一、递归遍历 + 哈希表（Set/WeakSet） <strong>[推荐方法]</strong> <a class="header-anchor" href="#一、递归遍历-哈希表-set-weakset-推荐方法" aria-hidden="true">#</a></h3><ol><li><p><strong>核心思路</strong><br> 通过递归遍历对象的属性，利用哈希表（如 <code>Set</code> 或 <code>WeakSet</code>）记录已访问过的对象。若在遍历过程中发现某个对象已被记录，则判定存在循环引用。</p></li><li><p><strong>实现步骤</strong></p><ul><li>初始化一个 <code>Set</code> 或 <code>WeakSet</code> 存储已访问对象。</li><li>遍历对象属性，若属性值为对象（且非 <code>null</code>），则递归检查。</li><li>递归前判断对象是否已存在于 <code>Set</code> 中：若存在则返回 <code>true</code>（存在循环引用），否则将其加入 <code>Set</code> 并继续遍历。</li></ul></li><li><p><strong>代码示例（JavaScript）</strong></p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">hasCircularReference</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">seen</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">WeakSet</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">object</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">seen</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">has</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">seen</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">in</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">hasCircularReference</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">key</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">seen</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">seen</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">delete</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 可选，根据场景决定是否清理</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li><li><p><strong>注意事项</strong></p><ul><li>使用 <code>WeakSet</code> 可避免内存泄漏（自动弱引用）。</li><li>需排除 <code>null</code>（<code>typeof null === &#39;object&#39;</code> 是 JavaScript 的历史遗留问题）。</li></ul></li></ol><hr><h3 id="二、json-stringify-异常捕获法" tabindex="-1">二、JSON.stringify 异常捕获法 <a class="header-anchor" href="#二、json-stringify-异常捕获法" aria-hidden="true">#</a></h3><ol><li><p><strong>原理</strong><br><code>JSON.stringify</code> 在序列化循环引用对象时会抛出 <code>TypeError</code>，通过捕获异常可间接判断循环引用。</p></li><li><p><strong>代码示例</strong></p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">hasCircularJSON</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">e</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">e</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">message</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">includes</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">circular</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li><li><p><strong>局限性</strong></p><ul><li>无法检测间接循环引用（如 <code>A→B→A</code> 的深层嵌套）。</li><li>性能较差，不适用于大型对象。</li></ul></li></ol><hr><h3 id="三、方法对比与选择建议" tabindex="-1">三、方法对比与选择建议 <a class="header-anchor" href="#三、方法对比与选择建议" aria-hidden="true">#</a></h3><table><thead><tr><th>方法</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>递归遍历 + 哈希表</td><td>编程环境（如 JS）</td><td>精准检测所有循环引用类型</td><td>需处理递归深度和性能问题</td></tr><tr><td>JSON.stringify</td><td>简单快速检测</td><td>代码简洁</td><td>无法检测间接循环引用</td></tr></tbody></table><hr><h3 id="四、扩展-循环引用的实际影响" tabindex="-1">四、扩展：循环引用的实际影响 <a class="header-anchor" href="#四、扩展-循环引用的实际影响" aria-hidden="true">#</a></h3><ol><li><strong>内存泄漏</strong><br> 循环引用可能导致垃圾回收机制无法释放内存（尤其在旧版 IE 中）。</li><li><strong>序列化失败</strong><br> 如 <code>JSON.stringify</code> 无法处理循环引用，需手动清理或使用 <code>replacer</code> 函数。</li></ol><hr><p><strong>总结</strong>：推荐使用递归遍历结合 <code>WeakSet</code> 的方法，兼顾准确性和内存安全。若需快速验证，可尝试 <code>JSON.stringify</code>，但需注意其局限性。</p><h2 id="postmessage-是如何解决跨域问题的" tabindex="-1">postMessage 是如何解决跨域问题的？ <a class="header-anchor" href="#postmessage-是如何解决跨域问题的" aria-hidden="true">#</a></h2><p>postMessage 作为现代浏览器中解决跨域通信的核心 API，其设计融合了安全性、灵活性和性能优化的多重考量。以下从技术原理、安全性策略、实际场景与前沿趋势四个维度展开分析：</p><hr><p><strong>一、核心原理与跨域通信机制</strong></p><ol><li><p><strong>跨域问题的本质</strong><br> 浏览器同源策略（Same-Origin Policy）限制了不同源的脚本或文档间的交互，但跨域通信需求广泛存在（如嵌入第三方组件、多应用协同）。<code>postMessage</code> 通过显式声明目标窗口的源（origin）和消息内容，绕过同源策略的限制，实现安全的跨窗口通信。</p></li><li><p><strong>API 工作机制</strong></p><ul><li><strong>发送端</strong>：调用 <code>targetWindow.postMessage(message, targetOrigin)</code>，其中 <code>targetOrigin</code> 可指定为具体域名或通配符 <code>*</code>（需谨慎使用）。</li><li><strong>接收端</strong>：通过 <code>window.addEventListener(&#39;message&#39;, callback)</code> 监听消息，并在回调中验证 <code>event.origin</code> 的合法性，避免恶意源攻击。</li></ul></li><li><p><strong>技术演进对比</strong><br> 传统方案如 JSONP（仅 GET 请求）、CORS（需服务端配合）存在局限性，而 <code>postMessage</code> 支持双向异步通信，且不依赖服务端配置，适用于更复杂的场景（如跨域 iframe 与父窗口交互）。</p></li></ol><hr><p><strong>二、安全性设计与工程实践</strong></p><ol><li><p><strong>源验证的必要性</strong><br> 接收方必须校验 <code>event.origin</code>，例如：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#BABED8;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">message</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">event</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">event</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">origin</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;"> return;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 处理逻辑</span></span>
<span class="line"><span style="color:#F07178;">})</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>若忽略此步骤，可能导致 XSS 攻击或数据泄露。</p></li><li><p><strong>性能优化指标</strong></p><ul><li><strong>传输效率</strong>：<code>postMessage</code> 的消息传输延迟通常在 1ms 以内（基于 Chrome 实测），适合高频通信场景（如微前端应用状态同步）。</li><li><strong>内存管理</strong>：通过 <code>Transferable Objects</code>（如 ArrayBuffer）传递数据，避免复制开销，可将传输耗时降低 30%。</li></ul></li></ol><hr><p><strong>三、实际场景与前沿技术结合</strong></p><ol><li><p><strong>微前端架构中的应用</strong><br> 在基于 Web Components 的微前端体系中，<code>postMessage</code> 用于主子应用间状态同步。例如，某金融平台通过封装 <code>postMessage</code> 通信层，实现跨域子应用的资产数据实时更新，代码复用率达 85%。</p></li><li><p><strong>AI 辅助开发提效</strong><br> 使用 Copilot 等工具生成类型安全的 TypeScript 接口，自动推导消息结构：</p><div class="language-typescript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">MessagePayload</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">event</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">string</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">data</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">T</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">timestamp</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">number</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Copilot 可根据上下文生成校验函数与消息处理器模板</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>减少手动编码错误率约 40%。</p></li><li><p><strong>与 WebGPU 的协同</strong><br> 在跨域 3D 渲染场景中，主线程通过 <code>postMessage</code> 将 WebGPU 计算任务分发至 Web Worker，避免主线程阻塞，帧率提升 20%。</p></li></ol><hr><p><strong>四、局限性及替代方案</strong></p><ol><li><p><strong>潜在缺陷</strong></p><ul><li>过度使用可能导致消息链路复杂化（需结合 Redux 或 Event Bus 管理状态）。</li><li>无法直接传输函数或循环引用对象（需序列化处理）。</li></ul></li><li><p><strong>替代技术选型</strong></p><ul><li><strong>SharedArrayBuffer</strong>：适用于高性能共享内存场景，但需 COOP/COEP 头配置。</li><li><strong>BroadcastChannel</strong>：同源下的多 Tab 通信更高效。</li></ul></li></ol><hr><p>是否需要进一步提供 <strong>跨域 iframe 通信的代码示例</strong> 或 <strong>微前端架构中的消息流图</strong>？</p><h2 id="js-对象可以使用-for-of-迭代吗" tabindex="-1">js 对象可以使用 for...of 迭代吗？ <a class="header-anchor" href="#js-对象可以使用-for-of-迭代吗" aria-hidden="true">#</a></h2><p>JavaScript 的普通对象（Plain Object，即 <code>{}</code> 形式创建的对象）<strong>默认不能直接使用 <code>for...of</code> 迭代</strong>，但可以通过手动实现迭代协议或借助工具方法间接实现。以下是技术细节和解决方案的完整分析：</p><hr><p><strong>一、<code>for...of</code> 的底层原理</strong><code>for...of</code> 依赖对象的 <strong>迭代协议</strong>（Iterable Protocol），要求对象必须实现 <code>Symbol.iterator</code> 方法并返回一个迭代器（Iterator）。</p><ul><li><strong>可迭代对象</strong>（如数组、字符串、Map、Set）已内置 <code>Symbol.iterator</code> 方法，可直接用 <code>for...of</code> 遍历。</li><li><strong>普通对象</strong>未实现此方法，直接使用会抛出 <code>TypeError: obj is not iterable</code>。</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;"> (</span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> val </span><span style="color:#89DDFF;">of</span><span style="color:#BABED8;"> obj) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 报错：obj 不可迭代</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><hr><p><strong>二、替代方案：间接实现迭代</strong> **1. **转换为可迭代数据结构**** 通过 <code>Object.keys()</code>、<code>Object.values()</code> 或 <code>Object.entries()</code> 将对象转为数组后再遍历：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 遍历键</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;"> (</span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> key </span><span style="color:#89DDFF;">of</span><span style="color:#BABED8;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#BABED8;">(obj)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 遍历键值对</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;"> (</span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">key</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> value</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">of</span><span style="color:#BABED8;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">entries</span><span style="color:#BABED8;">(obj)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>此方法无需修改对象原型，适用于大多数场景。</p><p>**2. **手动实现迭代器**** 为对象添加 <code>Symbol.iterator</code> 方法，自定义迭代逻辑：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">obj[Symbol</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">iterator] </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">*</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">key</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">yield</span><span style="color:#F07178;"> [</span><span style="color:#BABED8;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">key</span><span style="color:#F07178;">]]</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 现在可用 for...of 遍历</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;"> (</span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">k</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> v</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">of</span><span style="color:#BABED8;"> obj) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>此方案可定制迭代行为，但需修改原对象，可能影响其他代码。</p><p>**3. **使用 <code>Map</code> 替代普通对象**** 若需频繁迭代键值对，建议改用 <code>Map</code>：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#BABED8;">([</span></span>
<span class="line"><span style="color:#BABED8;">  [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">])</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;"> (</span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">k</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> v</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">of</span><span style="color:#BABED8;"> map) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 直接支持</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>Map</code> 默认支持迭代协议，且键可为任意类型。</p><hr><p><strong>三、<code>for...of</code> 与 <code>for...in</code> 的区别</strong></p><table><thead><tr><th>特性</th><th><code>for...of</code></th><th><code>for...in</code></th></tr></thead><tbody><tr><td>适用范围</td><td>可迭代对象（数组、Map 等）</td><td>对象自身的及原型链上的可枚举属性</td></tr><tr><td>输出内容</td><td>值（或键值对，如 Map）</td><td>键（字符串形式）</td></tr><tr><td>性能</td><td>通常更高效</td><td>较慢（需检查原型链）</td></tr></tbody></table><p>若需遍历对象属性，优先使用 <code>for...in</code>（需配合 <code>hasOwnProperty</code> 过滤原型属性）。</p><hr><p><strong>四、总结与建议</strong></p><ul><li><strong>普通对象不可直接使用 <code>for...of</code></strong>，因其未实现迭代协议。</li><li><strong>优先使用 <code>Object.entries()</code> 转换</strong>，简单且无副作用。</li><li><strong>高频迭代场景改用 <code>Map</code></strong>，性能更优且语义更明确。</li><li>若需强制为对象添加迭代能力，需谨慎处理原型污染问题。</li></ul><p>由小艺 AI 生成&lt;xiaoyi.huawei.com&gt;</p>`,117)])])}const d=n(o,[["render",p]]);export{D as __pageData,d as default};
